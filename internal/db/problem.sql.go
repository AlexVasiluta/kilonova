// Code generated by sqlc. DO NOT EDIT.
// source: problem.sql

package db

import (
	"context"
)

const countProblems = `-- name: CountProblems :one
SELECT COUNT(*) FROM problems 
WHERE lower(name) = lower($1)
`

func (q *Queries) CountProblems(ctx context.Context, name string) (int64, error) {
	row := q.queryRow(ctx, q.countProblemsStmt, countProblems, name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProblem = `-- name: CreateProblem :one
INSERT INTO problems (
	name, author_id, console_input, test_name, memory_limit, stack_limit, time_limit 
) VALUES (
	$1, $2, $3, $4, $5, $6, $7
)
RETURNING id
`

type CreateProblemParams struct {
	Name         string  `json:"name"`
	AuthorID     int64   `json:"author_id"`
	ConsoleInput bool    `json:"console_input"`
	TestName     string  `json:"test_name"`
	MemoryLimit  int32   `json:"memory_limit"`
	StackLimit   int32   `json:"stack_limit"`
	TimeLimit    float64 `json:"time_limit"`
}

func (q *Queries) CreateProblem(ctx context.Context, arg CreateProblemParams) (int64, error) {
	row := q.queryRow(ctx, q.createProblemStmt, createProblem,
		arg.Name,
		arg.AuthorID,
		arg.ConsoleInput,
		arg.TestName,
		arg.MemoryLimit,
		arg.StackLimit,
		arg.TimeLimit,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const problem = `-- name: Problem :one
SELECT id, created_at, name, description, test_name, author_id, time_limit, memory_limit, stack_limit, source_size, console_input, visible FROM problems
WHERE id = $1
`

func (q *Queries) Problem(ctx context.Context, id int64) (Problem, error) {
	row := q.queryRow(ctx, q.problemStmt, problem, id)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.Description,
		&i.TestName,
		&i.AuthorID,
		&i.TimeLimit,
		&i.MemoryLimit,
		&i.StackLimit,
		&i.SourceSize,
		&i.ConsoleInput,
		&i.Visible,
	)
	return i, err
}

const problemTests = `-- name: ProblemTests :many
SELECT id, created_at, score, problem_id, visible_id, orphaned FROM tests 
WHERE problem_id = $1 AND orphaned = false
ORDER BY visible_id
`

func (q *Queries) ProblemTests(ctx context.Context, problemID int64) ([]Test, error) {
	rows, err := q.query(ctx, q.problemTestsStmt, problemTests, problemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Test
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Score,
			&i.ProblemID,
			&i.VisibleID,
			&i.Orphaned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const problems = `-- name: Problems :many
SELECT id, created_at, name, description, test_name, author_id, time_limit, memory_limit, stack_limit, source_size, console_input, visible FROM problems
ORDER BY id
`

func (q *Queries) Problems(ctx context.Context) ([]Problem, error) {
	rows, err := q.query(ctx, q.problemsStmt, problems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Problem
	for rows.Next() {
		var i Problem
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.Description,
			&i.TestName,
			&i.AuthorID,
			&i.TimeLimit,
			&i.MemoryLimit,
			&i.StackLimit,
			&i.SourceSize,
			&i.ConsoleInput,
			&i.Visible,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const purgePbTests = `-- name: PurgePbTests :exec
UPDATE tests 
SET orphaned = true
WHERE problem_id = $1
`

// Since there is a key constraint on these tests, instead of removing them, we simply orphan them so they don't get used in the future
func (q *Queries) PurgePbTests(ctx context.Context, problemID int64) error {
	_, err := q.exec(ctx, q.purgePbTestsStmt, purgePbTests, problemID)
	return err
}

const setConsoleInput = `-- name: SetConsoleInput :exec
UPDATE problems 
SET console_input = $2
WHERE id = $1
`

type SetConsoleInputParams struct {
	ID           int64 `json:"id"`
	ConsoleInput bool  `json:"console_input"`
}

func (q *Queries) SetConsoleInput(ctx context.Context, arg SetConsoleInputParams) error {
	_, err := q.exec(ctx, q.setConsoleInputStmt, setConsoleInput, arg.ID, arg.ConsoleInput)
	return err
}

const setLimits = `-- name: SetLimits :exec
UPDATE problems 
SET memory_limit = $2, stack_limit = $3, time_limit = $4
WHERE id = $1
`

type SetLimitsParams struct {
	ID          int64   `json:"id"`
	MemoryLimit int32   `json:"memory_limit"`
	StackLimit  int32   `json:"stack_limit"`
	TimeLimit   float64 `json:"time_limit"`
}

func (q *Queries) SetLimits(ctx context.Context, arg SetLimitsParams) error {
	_, err := q.exec(ctx, q.setLimitsStmt, setLimits,
		arg.ID,
		arg.MemoryLimit,
		arg.StackLimit,
		arg.TimeLimit,
	)
	return err
}

const setMemoryLimit = `-- name: SetMemoryLimit :exec
UPDATE problems
SET memory_limit = $2
WHERE id = $1
`

type SetMemoryLimitParams struct {
	ID          int64 `json:"id"`
	MemoryLimit int32 `json:"memory_limit"`
}

func (q *Queries) SetMemoryLimit(ctx context.Context, arg SetMemoryLimitParams) error {
	_, err := q.exec(ctx, q.setMemoryLimitStmt, setMemoryLimit, arg.ID, arg.MemoryLimit)
	return err
}

const setProblemDescription = `-- name: SetProblemDescription :exec
UPDATE problems 
SET description = $2
WHERE id = $1
`

type SetProblemDescriptionParams struct {
	ID          int64  `json:"id"`
	Description string `json:"description"`
}

func (q *Queries) SetProblemDescription(ctx context.Context, arg SetProblemDescriptionParams) error {
	_, err := q.exec(ctx, q.setProblemDescriptionStmt, setProblemDescription, arg.ID, arg.Description)
	return err
}

const setProblemName = `-- name: SetProblemName :exec
UPDATE problems 
SET name = $2 
WHERE id = $1
`

type SetProblemNameParams struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) SetProblemName(ctx context.Context, arg SetProblemNameParams) error {
	_, err := q.exec(ctx, q.setProblemNameStmt, setProblemName, arg.ID, arg.Name)
	return err
}

const setProblemVisibility = `-- name: SetProblemVisibility :exec
UPDATE problems 
SET visible = $2
WHERE id = $1
`

type SetProblemVisibilityParams struct {
	ID      int64 `json:"id"`
	Visible bool  `json:"visible"`
}

func (q *Queries) SetProblemVisibility(ctx context.Context, arg SetProblemVisibilityParams) error {
	_, err := q.exec(ctx, q.setProblemVisibilityStmt, setProblemVisibility, arg.ID, arg.Visible)
	return err
}

const setStackLimit = `-- name: SetStackLimit :exec
UPDATE problems
SET stack_limit = $2
WHERE id = $1
`

type SetStackLimitParams struct {
	ID         int64 `json:"id"`
	StackLimit int32 `json:"stack_limit"`
}

func (q *Queries) SetStackLimit(ctx context.Context, arg SetStackLimitParams) error {
	_, err := q.exec(ctx, q.setStackLimitStmt, setStackLimit, arg.ID, arg.StackLimit)
	return err
}

const setTestName = `-- name: SetTestName :exec
UPDATE problems 
SET test_name = $2
WHERE id = $1
`

type SetTestNameParams struct {
	ID       int64  `json:"id"`
	TestName string `json:"test_name"`
}

func (q *Queries) SetTestName(ctx context.Context, arg SetTestNameParams) error {
	_, err := q.exec(ctx, q.setTestNameStmt, setTestName, arg.ID, arg.TestName)
	return err
}

const setTimeLimit = `-- name: SetTimeLimit :exec
UPDATE problems
SET time_limit = $2
WHERE id = $1
`

type SetTimeLimitParams struct {
	ID        int64   `json:"id"`
	TimeLimit float64 `json:"time_limit"`
}

func (q *Queries) SetTimeLimit(ctx context.Context, arg SetTimeLimitParams) error {
	_, err := q.exec(ctx, q.setTimeLimitStmt, setTimeLimit, arg.ID, arg.TimeLimit)
	return err
}

const visibleProblems = `-- name: VisibleProblems :many
SELECT id, created_at, name, description, test_name, author_id, time_limit, memory_limit, stack_limit, source_size, console_input, visible FROM problems 
WHERE visible = true OR author_id = $1
ORDER BY id
`

func (q *Queries) VisibleProblems(ctx context.Context, authorID int64) ([]Problem, error) {
	rows, err := q.query(ctx, q.visibleProblemsStmt, visibleProblems, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Problem
	for rows.Next() {
		var i Problem
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.Description,
			&i.TestName,
			&i.AuthorID,
			&i.TimeLimit,
			&i.MemoryLimit,
			&i.StackLimit,
			&i.SourceSize,
			&i.ConsoleInput,
			&i.Visible,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
