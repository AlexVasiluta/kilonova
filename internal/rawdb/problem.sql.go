// Code generated by sqlc. DO NOT EDIT.
// source: problem.sql

package rawdb

import (
	"context"
)

const createProblem = `-- name: CreateProblem :one
INSERT INTO problems (
	name, author_id, console_input, test_name, memory_limit, stack_limit, time_limit 
) VALUES (
	$1, $2, $3, $4, $5, $6, $7
)
RETURNING id, created_at, name, description, test_name, author_id, time_limit, memory_limit, stack_limit, source_size, console_input, visible, credits
`

type CreateProblemParams struct {
	Name         string  `json:"name"`
	AuthorID     int64   `json:"author_id"`
	ConsoleInput bool    `json:"console_input"`
	TestName     string  `json:"test_name"`
	MemoryLimit  int32   `json:"memory_limit"`
	StackLimit   int32   `json:"stack_limit"`
	TimeLimit    float64 `json:"time_limit"`
}

func (q *Queries) CreateProblem(ctx context.Context, arg CreateProblemParams) (Problem, error) {
	row := q.db.QueryRowContext(ctx, createProblem,
		arg.Name,
		arg.AuthorID,
		arg.ConsoleInput,
		arg.TestName,
		arg.MemoryLimit,
		arg.StackLimit,
		arg.TimeLimit,
	)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.Description,
		&i.TestName,
		&i.AuthorID,
		&i.TimeLimit,
		&i.MemoryLimit,
		&i.StackLimit,
		&i.SourceSize,
		&i.ConsoleInput,
		&i.Visible,
		&i.Credits,
	)
	return i, err
}

const problem = `-- name: Problem :one
SELECT id, created_at, name, description, test_name, author_id, time_limit, memory_limit, stack_limit, source_size, console_input, visible, credits FROM problems
WHERE id = $1
`

func (q *Queries) Problem(ctx context.Context, id int64) (Problem, error) {
	row := q.db.QueryRowContext(ctx, problem, id)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.Description,
		&i.TestName,
		&i.AuthorID,
		&i.TimeLimit,
		&i.MemoryLimit,
		&i.StackLimit,
		&i.SourceSize,
		&i.ConsoleInput,
		&i.Visible,
		&i.Credits,
	)
	return i, err
}

const problemByName = `-- name: ProblemByName :one
SELECT id, created_at, name, description, test_name, author_id, time_limit, memory_limit, stack_limit, source_size, console_input, visible, credits FROM problems
WHERE lower(name) = lower($1)
`

func (q *Queries) ProblemByName(ctx context.Context, name string) (Problem, error) {
	row := q.db.QueryRowContext(ctx, problemByName, name)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.Description,
		&i.TestName,
		&i.AuthorID,
		&i.TimeLimit,
		&i.MemoryLimit,
		&i.StackLimit,
		&i.SourceSize,
		&i.ConsoleInput,
		&i.Visible,
		&i.Credits,
	)
	return i, err
}

const problemTests = `-- name: ProblemTests :many
SELECT id, created_at, score, problem_id, visible_id, orphaned FROM tests 
WHERE problem_id = $1 AND orphaned = false
ORDER BY visible_id
`

func (q *Queries) ProblemTests(ctx context.Context, problemID int64) ([]Test, error) {
	rows, err := q.db.QueryContext(ctx, problemTests, problemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Test
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Score,
			&i.ProblemID,
			&i.VisibleID,
			&i.Orphaned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const problems = `-- name: Problems :many
SELECT id, created_at, name, description, test_name, author_id, time_limit, memory_limit, stack_limit, source_size, console_input, visible, credits FROM problems
ORDER BY id
`

func (q *Queries) Problems(ctx context.Context) ([]Problem, error) {
	rows, err := q.db.QueryContext(ctx, problems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Problem
	for rows.Next() {
		var i Problem
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.Description,
			&i.TestName,
			&i.AuthorID,
			&i.TimeLimit,
			&i.MemoryLimit,
			&i.StackLimit,
			&i.SourceSize,
			&i.ConsoleInput,
			&i.Visible,
			&i.Credits,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const purgePbTests = `-- name: PurgePbTests :exec
UPDATE tests 
SET orphaned = true
WHERE problem_id = $1
`

// Since there is a key constraint on these tests, instead of removing them, we simply orphan them so they don't get used in the future
func (q *Queries) PurgePbTests(ctx context.Context, problemID int64) error {
	_, err := q.db.ExecContext(ctx, purgePbTests, problemID)
	return err
}

const setConsoleInput = `-- name: SetConsoleInput :exec
UPDATE problems 
SET console_input = $2
WHERE id = $1
`

type SetConsoleInputParams struct {
	ID           int64 `json:"id"`
	ConsoleInput bool  `json:"console_input"`
}

func (q *Queries) SetConsoleInput(ctx context.Context, arg SetConsoleInputParams) error {
	_, err := q.db.ExecContext(ctx, setConsoleInput, arg.ID, arg.ConsoleInput)
	return err
}

const setLimits = `-- name: SetLimits :exec
UPDATE problems 
SET memory_limit = $2, stack_limit = $3, time_limit = $4
WHERE id = $1
`

type SetLimitsParams struct {
	ID          int64   `json:"id"`
	MemoryLimit int32   `json:"memory_limit"`
	StackLimit  int32   `json:"stack_limit"`
	TimeLimit   float64 `json:"time_limit"`
}

func (q *Queries) SetLimits(ctx context.Context, arg SetLimitsParams) error {
	_, err := q.db.ExecContext(ctx, setLimits,
		arg.ID,
		arg.MemoryLimit,
		arg.StackLimit,
		arg.TimeLimit,
	)
	return err
}

const setMemoryLimit = `-- name: SetMemoryLimit :exec
UPDATE problems
SET memory_limit = $2
WHERE id = $1
`

type SetMemoryLimitParams struct {
	ID          int64 `json:"id"`
	MemoryLimit int32 `json:"memory_limit"`
}

func (q *Queries) SetMemoryLimit(ctx context.Context, arg SetMemoryLimitParams) error {
	_, err := q.db.ExecContext(ctx, setMemoryLimit, arg.ID, arg.MemoryLimit)
	return err
}

const setPbCredits = `-- name: SetPbCredits :exec
UPDATE problems
SET credits = $2
WHERE id = $1
`

type SetPbCreditsParams struct {
	ID      int64  `json:"id"`
	Credits string `json:"credits"`
}

func (q *Queries) SetPbCredits(ctx context.Context, arg SetPbCreditsParams) error {
	_, err := q.db.ExecContext(ctx, setPbCredits, arg.ID, arg.Credits)
	return err
}

const setPbDescription = `-- name: SetPbDescription :exec
UPDATE problems 
SET description = $2
WHERE id = $1
`

type SetPbDescriptionParams struct {
	ID          int64  `json:"id"`
	Description string `json:"description"`
}

func (q *Queries) SetPbDescription(ctx context.Context, arg SetPbDescriptionParams) error {
	_, err := q.db.ExecContext(ctx, setPbDescription, arg.ID, arg.Description)
	return err
}

const setPbName = `-- name: SetPbName :exec
UPDATE problems 
SET name = $2 
WHERE id = $1
`

type SetPbNameParams struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) SetPbName(ctx context.Context, arg SetPbNameParams) error {
	_, err := q.db.ExecContext(ctx, setPbName, arg.ID, arg.Name)
	return err
}

const setPbVisibility = `-- name: SetPbVisibility :exec
UPDATE problems 
SET visible = $2
WHERE id = $1
`

type SetPbVisibilityParams struct {
	ID      int64 `json:"id"`
	Visible bool  `json:"visible"`
}

func (q *Queries) SetPbVisibility(ctx context.Context, arg SetPbVisibilityParams) error {
	_, err := q.db.ExecContext(ctx, setPbVisibility, arg.ID, arg.Visible)
	return err
}

const setStackLimit = `-- name: SetStackLimit :exec
UPDATE problems
SET stack_limit = $2
WHERE id = $1
`

type SetStackLimitParams struct {
	ID         int64 `json:"id"`
	StackLimit int32 `json:"stack_limit"`
}

func (q *Queries) SetStackLimit(ctx context.Context, arg SetStackLimitParams) error {
	_, err := q.db.ExecContext(ctx, setStackLimit, arg.ID, arg.StackLimit)
	return err
}

const setTestName = `-- name: SetTestName :exec
UPDATE problems 
SET test_name = $2
WHERE id = $1
`

type SetTestNameParams struct {
	ID       int64  `json:"id"`
	TestName string `json:"test_name"`
}

func (q *Queries) SetTestName(ctx context.Context, arg SetTestNameParams) error {
	_, err := q.db.ExecContext(ctx, setTestName, arg.ID, arg.TestName)
	return err
}

const setTimeLimit = `-- name: SetTimeLimit :exec
UPDATE problems
SET time_limit = $2
WHERE id = $1
`

type SetTimeLimitParams struct {
	ID        int64   `json:"id"`
	TimeLimit float64 `json:"time_limit"`
}

func (q *Queries) SetTimeLimit(ctx context.Context, arg SetTimeLimitParams) error {
	_, err := q.db.ExecContext(ctx, setTimeLimit, arg.ID, arg.TimeLimit)
	return err
}

const visibleProblems = `-- name: VisibleProblems :many
SELECT id, created_at, name, description, test_name, author_id, time_limit, memory_limit, stack_limit, source_size, console_input, visible, credits FROM problems 
WHERE visible = true OR author_id = $1
ORDER BY id
`

func (q *Queries) VisibleProblems(ctx context.Context, authorID int64) ([]Problem, error) {
	rows, err := q.db.QueryContext(ctx, visibleProblems, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Problem
	for rows.Next() {
		var i Problem
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.Description,
			&i.TestName,
			&i.AuthorID,
			&i.TimeLimit,
			&i.MemoryLimit,
			&i.StackLimit,
			&i.SourceSize,
			&i.ConsoleInput,
			&i.Visible,
			&i.Credits,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
